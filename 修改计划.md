# 令牌动态切换改造计划（auth_token/ct0 可随时变更）

## 背景与现状
- 目前通过环境变量设置 Twitter 登录所需的两项值：
  - `TWITTER_AUTH_TOKEN`（即 cookie 中的 `auth_token`）
  - `TWITTER_CSRF_TOKEN`（即 cookie 中的 `ct0`，同时用于 `x-csrf-token` 头）
- 代码直接从 `process.env` 读取，运行期无法变更：
  - `src/api/base/twitter-base.api.ts`：`getAuthHeaders()` 直接读 `process.env`
  - `src/utils/Util.ts`：`getTwitterAuthToken()` 直接读 `process.env`
  - `src/modules/UserListWatcher.ts`：构造 `cookie: auth_token=...`
  - `src/index.ts`：仅做环境变量调试打印（掩码）
- 需求：在不重启进程的前提下，可随时切换账号（轮换 `auth_token/ct0`），以规避账号级别限流。

## 改造目标
- 引入“单一可信源”的全局令牌管理器，支持运行时动态更新。
- 所有请求在发起前从管理器读取最新 token，避免缓存旧值。
- 兼容现有 `.env` 配置；在未显式设置时仍可按旧逻辑工作。
- 避免日志泄露敏感信息（统一掩码）。

## 总体方案
1. 新增 `TokenManager`（单例）：内存持有 `authToken` 与 `csrfToken`，提供 `get/set` API、构造标准头/ cookie 的方法。
2. 将所有使用 `process.env.TWITTER_AUTH_TOKEN/CSRF_TOKEN` 的位置改为从 `TokenManager` 读取。
3. 提供多种更新渠道（就近最小改动优先）：
   - 启动参数：`--auth-token`、`--csrf-token`（一次性覆盖初始值）。
   - 运行期热更新（推荐）：监听一个 `tokens.json` 文件（或复用 `config.json` 的 `tokens` 字段），文件变更后自动 `TokenManager.set*()`。
   - 保持 `.env` 作为兜底初始值（进程启动时读取一次）。

## 详细变更清单
### 1) 新增全局令牌管理器
- 新增文件：`src/modules/TokenManager.ts`
  - 建议 API：
    - `getAuthToken(): string | undefined`
    - `getCsrfToken(): string | undefined`
    - `setAuthToken(token?: string): void`
    - `setCsrfToken(token?: string): void`
    - `getCookie(): string`（例如：`auth_token=...; ct0=...`，仅拼接存在的键）
    - `getAuthHeaders(): Record<string,string>`（含 `authorization`, `cookie`, `x-csrf-token`）
  - 初始化来源顺序：CLI 参数 > `tokens.json`（如存在且可读）> `.env`
  - 可选：内置 `fs.watchFile` 监听 `tokens.json`，去抖 200–500ms，出错时记录 warn。
  - 参考实现（示例骨架）：
    ```ts
    // src/modules/TokenManager.ts
    import fs from 'fs'
    import path from 'path'
    import { TWITTER_PUBLIC_AUTHORIZATION } from '../constants/twitter.constant'
    
    class TokenManager {
      private authToken?: string
      private csrfToken?: string
      private tokensPath?: string
      
      init(opts?: { authToken?: string; csrfToken?: string; tokensPath?: string }) {
        this.tokensPath = opts?.tokensPath
        // 1) CLI 覆盖
        this.authToken = opts?.authToken ?? this.authToken
        this.csrfToken = opts?.csrfToken ?? this.csrfToken
        // 2) 文件读取
        this.loadFromFile()
        // 3) .env 兜底
        this.authToken ??= process.env.TWITTER_AUTH_TOKEN
        this.csrfToken ??= process.env.TWITTER_CSRF_TOKEN
        // 热更新
        this.watch()
      }
      
      getAuthToken() { return this.authToken }
      getCsrfToken() { return this.csrfToken }
      setAuthToken(v?: string) { this.authToken = v }
      setCsrfToken(v?: string) { this.csrfToken = v }
      
      getCookie() {
        const parts = [] as string[]
        if (this.authToken) parts.push(`auth_token=${this.authToken}`)
        if (this.csrfToken) parts.push(`ct0=${this.csrfToken}`)
        return parts.join('; ')
      }
      
      getAuthHeaders() {
        const cookie = this.getCookie()
        const headers: Record<string, string> = { authorization: TWITTER_PUBLIC_AUTHORIZATION }
        if (cookie) headers.cookie = cookie
        if (this.csrfToken) headers['x-csrf-token'] = this.csrfToken
        return headers
      }
      
      private loadFromFile() {
        try {
          if (!this.tokensPath) return
          if (!fs.existsSync(this.tokensPath)) return
          const { authToken, csrfToken } = JSON.parse(fs.readFileSync(this.tokensPath, 'utf-8'))
          this.authToken = authToken ?? this.authToken
          this.csrfToken = csrfToken ?? this.csrfToken
        } catch {}
      }
      
      private watch() {
        if (!this.tokensPath) return
        try {
          let timer: NodeJS.Timeout
          fs.watchFile(this.tokensPath, { interval: 500 }, () => {
            clearTimeout(timer)
            timer = setTimeout(() => this.loadFromFile(), 250)
          })
        } catch {}
      }
    }
    
    export const tokenManager = new TokenManager()
    ```

### 2) 替换直接读取 env 的代码
- `src/api/base/twitter-base.api.ts`
  - `getAuthHeaders()` 内：
    - 替换 `process.env.TWITTER_AUTH_TOKEN`、`process.env.TWITTER_CSRF_TOKEN` 为 `TokenManager.getAuthToken()`、`TokenManager.getCsrfToken()`。
    - 或直接委托 `TokenManager.getAuthHeaders()`（更统一）。
    - 参考改动：
      ```ts
      // import { tokenManager } from '../../modules/TokenManager'
      protected getAuthHeaders() {
        return tokenManager.getAuthHeaders()
      }
      ```

- `src/utils/Util.ts`
  - `getTwitterAuthToken()` 改为从 `TokenManager.getAuthToken()` 读取；
  - 新增 `getTwitterCsrfToken()` 时从 `TokenManager.getCsrfToken()` 读取（如需要）。
  - 参考改动：
    ```ts
    // import { tokenManager } from '../modules/TokenManager'
    public static getTwitterAuthToken(): string { return tokenManager.getAuthToken() }
    public static getTwitterCsrfToken(): string { return tokenManager.getCsrfToken() }
    ```

- `src/modules/UserListWatcher.ts`
  - 构造 `headers.cookie` 的位置，改用 `TokenManager.getCookie()`（或 `Util` 的包装）。
  - 参考改动：
    ```ts
    // import { tokenManager } from '../modules/TokenManager'
    const data = await TwitterApi.getSpacesByFleetsAvatarContent(
      userIds,
      {
        authorization: TWITTER_PUBLIC_AUTHORIZATION,
        cookie: tokenManager.getCookie(),
      },
    )
    ```

- 旧封装 `src/apis/TwitterApi.ts`
  - 调用处传入的 `headers` 如仍手动组装 cookie，统一改为使用 `TokenManager` 的输出，避免分叉。

### 3) CLI 支持注入/覆盖令牌（启动态）
- `src/index.ts`
  - 增加选项：`--auth-token <TOKEN>`、`--csrf-token <TOKEN>`。
  - 在 `program.action` 中，若传入则调用 `TokenManager.setAuthToken/ setCsrfToken` 覆盖初始值。
  - 调试打印更新为读取 `TokenManager` 值，统一按前 16 位+掩码展示。
  - 参考改动：
    ```ts
    program
      .option('--auth-token <TOKEN>')
      .option('--csrf-token <TOKEN>')
    
    program.action(async (args) => {
      // 初始化 TokenManager（含 tokens.json 路径）
      tokenManager.init({
        authToken: args.authToken,
        csrfToken: args.csrfToken,
        tokensPath: path.join(process.cwd(), 'logs', 'tokens.json'),
      })
      // 掩码打印
      const mask = (s?: string) => (s ? `${s.slice(0, 16)}****` : '')
      logger.debug(`token.auth=${mask(tokenManager.getAuthToken())}`)
      logger.debug(`token.csrf=${mask(tokenManager.getCsrfToken())}`)
      ...
    })
    ```

### 4) 运行期热更新（不重启生效）
- 新增 `tokens.json`（默认路径：项目根或 `./logs/tokens.json`，后者已被忽略更安全）。
  - 结构示例：
    ```json
    { "authToken": "xxx", "csrfToken": "yyy" }
    ```
  - `TokenManager` 在构造时尝试读取一次；设置文件监听，变更时热加载并调用 `set*()`。
  - 优先级：CLI > tokens.json（最新）> .env（初始）。

## 日志与安全
- 不输出完整令牌，仅打印前缀+掩码（与现状一致）。
- `tokens.json` 不纳入版本控制：
  - 更新 `.gitignore` 或建议放在 `logs/`（已忽略）。
  - 提供 `tokens.example.json` 示例。

## 兼容性
- 未提供 `--auth-token/--csrf-token` 且不存在 `tokens.json` 时，沿用 `.env` 值（与当前一致）。
- 对外 CLI 与现有配置保持可用；仅新增能力，不破坏原功能。

## 测试计划
- 单元测试：
  - `TokenManager`：get/set、优先级合并逻辑、`getCookie()/getAuthHeaders()` 输出。
  - `twitter-base.api.ts#getAuthHeaders()` 是否使用最新 Token。
- 集成测试：
  - 启动后更新 `tokens.json`，下一次轮询（`UserListWatcher`）应使用新 Cookie；
  - 401/403 后手动替换 token，验证无需重启即可恢复。

## 验证步骤（手工）
1. `npm start -- --user some_user --auth-token A1 --csrf-token C1`
2. 观察日志请求头（仅掩码）与接口成功；
3. 在运行中把 `logs/tokens.json` 改为 `{ "authToken": "A2", "csrfToken": "C2" }`；
4. 等待下一轮请求，确认服务端接收到新 Cookie（可从速率限制头或行为判断）。

## 风险与应对
- 文件监听在部分平台可能不稳定：加入重试与定时轮询兜底（可选）。
- 竞争条件：统一从 `TokenManager` 读取，更新为原子替换（一次性更新两值）。
- 令牌缺失：若任一缺失，`cookie` 仅拼接存在项；必要时回退到 guest/authorization 流程。

## 后续可选增强（非本次范围）
- 账户池（多组 `auth_token/ct0`）与基于速率/错误的自动轮换策略；
- 当某组合剩余额度为 0 或频繁 429 时自动切换；
- 结合 `x-rate-limit-*` 头做简单调度与冷却时间管理。

## 任务拆解与里程碑
1. 引入 `TokenManager`、接入 `twitter-base.api.ts` 与 `Util.ts`（最小改动跑通）。
2. CLI 参数注入（启动态覆盖）。
3. 文件热更新（监听 `logs/tokens.json`）。
4. 替换所有残余手动 cookie 组装点；
5. 单元/集成测试与文档（`README`、`INSTALLATION`、`tokens.example.json`）。

---
如需，我可以按以上步骤直接提交实现（优先交付 1+2，随后补 3）。
